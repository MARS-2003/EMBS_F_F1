enum State { RED, YELLOW, GREEN };
void setLights(State t);

// Traffic Light Pins
const int tPins[] = {10, 9, 8};

// Ultrasonic Pins
const int TRIG_PIN = 3;
const int ECHO_PIN = 4;

const int RED_TIME = 3000;
const int YELLOW_TIME = 2000;
const int GREEN_TIME = 3000;
const int SHORT_DELAY = 800;

State curr = RED;
State prev = RED;
bool pedReq = false;

// Helper to get distance from Ultrasonic Sensor
long getDistance() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  long duration = pulseIn(ECHO_PIN, HIGH, 8000);
  long distance = (duration == 0) ? 999 : (duration*0.034 / 2);

  Serial.print("Dist: ");
  Serial.print(distance);
  Serial.println(" cm");

  return distance;
}

void setLights(State t) {
  for (int i = 0; i < 3; i++) {
    digitalWrite(tPins[i], (i == t) ? HIGH : LOW);
  }
}

void checkSerialRx() {
  if (Serial.available() > 0) {
    char received = Serial.read();
    if (received == 'P') {
      pedReq = true;
    }
  }
}

void waitAndCheckRx(int ms) {
  for (int i = 0; i < ms; i += 20)
  {
    checkSerialRx();
    if(pedReq){
      delay(SHORT_DELAY);//end sooner if P is detact
      return;
    }
    delay(20);
  }
}
void extraPedTime() {
  while (true) {
    delay(1000);
    long x = getDistance();
    if (x >= 50) {
      break;   // no pedestrian, exit
    }
  }
}


void setup() {
  for (int i = 0; i < 3; i++) {
    pinMode(tPins[i], OUTPUT);
  }

  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  Serial.begin(9600);
  setLights(RED);
}

void loop() {
  switch (curr) {

   	case RED:
      setLights(RED);
      prev = RED;
      Serial.write('1');
      delay(RED_TIME);
    extraPedTime();
      pedReq = false;
    	
      Serial.write('0');
      curr = YELLOW;
      break;

    case YELLOW:
      setLights(YELLOW);
      Serial.write('0');
      waitAndCheckRx(YELLOW_TIME);
      curr = (prev == RED) ? GREEN : RED;
      break;

    case GREEN:
      setLights(GREEN);
      Serial.write('0');
      waitAndCheckRx(GREEN_TIME);
      prev = GREEN;
      curr = YELLOW;
      break;
  }
}
